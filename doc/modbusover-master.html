<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- Master.cpp -->
  <meta name="description" content="Modbus 客户端（主站）接口.">
  <title>Master Class | ModbusOver 0.5.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="index.html" translate="no">ModbusOver 0.5.0</a></li>
<li><a href="modbusover-module.html" translate="no">ModbusOver</a></li>
<li>Master</li>
<li id="buildversion">ModbusOver 0.5.0 Reference Documentation</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">Master Class</h1>
<span class="small-subtitle" translate="no">class <a href="modbusover-module.html" translate="no">ModbusOver</a>::Master</span>
<!-- $$$Master-brief -->
<p>Modbus 客户端（主站）接口. <a href="#details">More...</a></p>
<!-- @@@Master -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;Master.h&gt;</span></td></tr>
</table></div>
<ul>
<li><a href="modbusover-master-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#Master" translate="no">Master</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#dtor.Master" translate="no">~Master</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#asciiLF" translate="no">asciiLF</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#close" translate="no">close</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#connect" translate="no">connect</a></b>(const int &amp;<i>address</i>, const std::chrono::milliseconds &amp;<i>connectTimeout</i> = std::chrono::milliseconds(5000))</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ModbusOver::CommEventCounter </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#getCommEventCounter" translate="no">getCommEventCounter</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ModbusOver::CommEventLog </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#getCommEventLog" translate="no">getCommEventLog</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#maskWriteRegister" translate="no">maskWriteRegister</a></b>(uint16_t <i>address</i>, uint16_t <i>andMask</i>, uint16_t <i>orMask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::shared_ptr&lt;ProtocolDebug&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#protocolDebug" translate="no">protocolDebug</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint8_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readCoils" translate="no">readCoils</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfCoils</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint8_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readDiscreteInputs" translate="no">readDiscreteInputs</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfCoils</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint8_t </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readExceptionStatus" translate="no">readExceptionStatus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint16_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readHoldingRegisters" translate="no">readHoldingRegisters</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfRegisters</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint16_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readInputRegisters" translate="no">readInputRegisters</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfRegisters</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint16_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readWriteMultipleRegisters" translate="no">readWriteMultipleRegisters</a></b>(uint16_t <i>readStartAddress</i>, uint16_t <i>quantityToRead</i>, uint16_t <i>writeStartAddress</i>, std::vector&lt;uint16_t&gt; &amp;&amp;<i>writeData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint16_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#readWriteMultipleRegisters-1" translate="no">readWriteMultipleRegisters</a></b>(uint16_t <i>readStartAddress</i>, uint16_t <i>quantityToRead</i>, uint16_t <i>writeStartAddress</i>, const std::vector&lt;uint16_t&gt; &amp;<i>writeData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint8_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#reportServerID" translate="no">reportServerID</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;uint16_t&gt; </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#requestReadFIFOQueue" translate="no">requestReadFIFOQueue</a></b>(uint16_t <i>address</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const std::chrono::milliseconds &amp;</td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#rtsDelay" translate="no">rtsDelay</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setAsciiLF" translate="no">setAsciiLF</a></b>(char <i>lf</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setProtocolDebug" translate="no">setProtocolDebug</a></b>(std::shared_ptr&lt;ProtocolDebug&gt; <i>debug</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setRTSDelay" translate="no">setRTSDelay</a></b>(const std::chrono::milliseconds &amp;<i>delay</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setSlave" translate="no">setSlave</a></b>(uint8_t <i>slave</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setTimeout" translate="no">setTimeout</a></b>(const std::chrono::milliseconds &amp;<i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#setUseBigendianCRC16" translate="no">setUseBigendianCRC16</a></b>(bool <i>on</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint8_t </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#slave" translate="no">slave</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const std::chrono::milliseconds &amp;</td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#timeout" translate="no">timeout</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#useBigendianCRC16" translate="no">useBigendianCRC16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeMultipleCoils" translate="no">writeMultipleCoils</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfCoils</i>, std::vector&lt;uint8_t&gt; &amp;&amp;<i>states</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeMultipleCoils-1" translate="no">writeMultipleCoils</a></b>(uint16_t <i>startingAddress</i>, uint16_t <i>quantityOfCoils</i>, const std::vector&lt;uint8_t&gt; &amp;<i>states</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeMultipleRegisters" translate="no">writeMultipleRegisters</a></b>(uint16_t <i>startingAddress</i>, std::vector&lt;uint16_t&gt; &amp;&amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeMultipleRegisters-1" translate="no">writeMultipleRegisters</a></b>(uint16_t <i>startingAddress</i>, const std::vector&lt;uint16_t&gt; &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeSingleCoil" translate="no">writeSingleCoil</a></b>(uint16_t <i>address</i>, bool <i>on</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="modbusover-master.html#writeSingleRegister" translate="no">writeSingleRegister</a></b>(uint16_t <i>address</i>, uint16_t <i>value</i>)</td></tr>
</table></div>
<!-- $$$Master-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
</div>
<!-- @@@Master -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$Master[overload1]$$$Master -->
<h3 class="fn" translate="no" id="Master">Master::<span class="name">Master</span>()</h3>
<p>构造函数.</p>
<!-- @@@Master -->
<!-- $$$~Master[overload1]$$$~Master -->
<h3 class="fn" translate="no" id="dtor.Master"><code translate="no">[virtual noexcept] </code>Master::<span class="name">~Master</span>()</h3>
<p>析构函数.</p>
<!-- @@@~Master -->
<!-- $$$asciiLF[overload1]$$$asciiLF -->
<h3 class="fn" translate="no" id="asciiLF"><span class="type">char</span> Master::<span class="name">asciiLF</span>() const</h3>
<p>返回<a href="standard-h.html#ModbusProtocol-enum" translate="no">ModbusASCII</a>协议自定义LF</p>
<p><b>See also </b><a href="modbusover-master.html#setAsciiLF" translate="no">setAsciiLF</a>.</p>
<!-- @@@asciiLF -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" translate="no" id="close"><code translate="no">[noexcept] </code><span class="type">void</span> Master::<span class="name">close</span>()</h3>
<p>关闭连接.</p>
<p><b>See also </b><a href="modbusover-master.html#connect" translate="no">connect</a>.</p>
<!-- @@@close -->
<!-- $$$connect[overload1]$$$connectconstint&conststd::chrono::milliseconds& -->
<h3 class="fn" translate="no" id="connect">template &lt;int T&gt; <span class="type">void</span> Master::<span class="name">connect</span>(const <span class="type">int</span> &amp;<i>address</i>, const <span class="type">std::chrono::milliseconds</span> &amp;<i>connectTimeout</i> = std::chrono::milliseconds(5000))</h3>
<p>连接到地址为 <i translate="no">address</i> 的设备，连接超时时间为 <i translate="no">connectTimeout</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#close" translate="no">close</a>.</p>
<!-- @@@connect -->
<!-- $$$getCommEventCounter[overload1]$$$getCommEventCounter -->
<h3 class="fn" translate="no" id="getCommEventCounter"><span class="type"><a href="modbusover-commeventcounter.html" translate="no">ModbusOver::CommEventCounter</a></span> Master::<span class="name">getCommEventCounter</span>()</h3>
<p>获得事件计数器. 功能码 0x0B.</p>
<!-- @@@getCommEventCounter -->
<!-- $$$getCommEventLog[overload1]$$$getCommEventLog -->
<h3 class="fn" translate="no" id="getCommEventLog"><span class="type"><a href="modbusover-commeventlog.html" translate="no">ModbusOver::CommEventLog</a></span> Master::<span class="name">getCommEventLog</span>()</h3>
<p>获得事件记录. 功能码 0x0C.</p>
<!-- @@@getCommEventLog -->
<!-- $$$maskWriteRegister[overload1]$$$maskWriteRegisteruint16_tuint16_tuint16_t -->
<h3 class="fn" translate="no" id="maskWriteRegister"><span class="type">void</span> Master::<span class="name">maskWriteRegister</span>(<span class="type">uint16_t</span> <i>address</i>, <span class="type">uint16_t</span> <i>andMask</i>, <span class="type">uint16_t</span> <i>orMask</i>)</h3>
<p>掩码写入寄存器. 功能码 0x16. 写入寄存器地址 <i translate="no">address</i>, <i translate="no">andMask</i>, <i translate="no">orMask</i>. 算法为 Result = (当前寄存器内容 AND <i translate="no">andMask</i>) OR (<i translate="no">orMask</i> AND (NOT <i translate="no">andMask</i>)).</p>
<!-- @@@maskWriteRegister -->
<!-- $$$protocolDebug[overload1]$$$protocolDebug -->
<h3 class="fn" translate="no" id="protocolDebug"><span class="type">std::shared_ptr</span>&lt;<span class="type"><a href="modbusover-protocoldebug.html" translate="no">ProtocolDebug</a></span>&gt; Master::<span class="name">protocolDebug</span>() const</h3>
<p>返回底层协议调试接口.</p>
<p><b>See also </b><a href="modbusover-master.html#setProtocolDebug" translate="no">setProtocolDebug</a>.</p>
<!-- @@@protocolDebug -->
<!-- $$$readCoils[overload1]$$$readCoilsuint16_tuint16_t -->
<h3 class="fn" translate="no" id="readCoils"><span class="type">std::vector</span>&lt;<span class="type">uint8_t</span>&gt; Master::<span class="name">readCoils</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfCoils</i>)</h3>
<p>功能码 0x01, 读取从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfCoils</i> 个线圈.</p>
<div class="admonition note">
<p><b>Note: </b>quantityOfCoils表示线圈数量，每个线圈为 1 bit, 所以返回的字节数为 quantityOfCoils / 8 + ((quantityOfCoils % 8) ? 1 : 0).</p>
</div>
<p><b>See also </b><a href="modbusover-master.html#writeSingleCoil" translate="no">writeSingleCoil</a> and <a href="modbusover-master.html#writeMultipleCoils" translate="no">writeMultipleCoils</a>.</p>
<!-- @@@readCoils -->
<!-- $$$readDiscreteInputs[overload1]$$$readDiscreteInputsuint16_tuint16_t -->
<h3 class="fn" translate="no" id="readDiscreteInputs"><span class="type">std::vector</span>&lt;<span class="type">uint8_t</span>&gt; Master::<span class="name">readDiscreteInputs</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfCoils</i>)</h3>
<p>功能码 0x02, 读取从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfCoils</i> 个离散量输入（线圈），离散量输入为只读.</p>
<!-- @@@readDiscreteInputs -->
<!-- $$$readExceptionStatus[overload1]$$$readExceptionStatus -->
<h3 class="fn" translate="no" id="readExceptionStatus"><span class="type">uint8_t</span> Master::<span class="name">readExceptionStatus</span>()</h3>
<p>读异常状态. 功能码 0x07.</p>
<!-- @@@readExceptionStatus -->
<!-- $$$readHoldingRegisters[overload1]$$$readHoldingRegistersuint16_tuint16_t -->
<h3 class="fn" translate="no" id="readHoldingRegisters"><span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; Master::<span class="name">readHoldingRegisters</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfRegisters</i>)</h3>
<p>功能码 0x03, 读取从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfRegisters</i> 个保持寄存器.</p>
<p><b>See also </b><a href="modbusover-master.html#writeSingleRegister" translate="no">writeSingleRegister</a> and <a href="modbusover-master.html#writeMultipleRegisters" translate="no">writeMultipleRegisters</a>.</p>
<!-- @@@readHoldingRegisters -->
<!-- $$$readInputRegisters[overload1]$$$readInputRegistersuint16_tuint16_t -->
<h3 class="fn" translate="no" id="readInputRegisters"><span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; Master::<span class="name">readInputRegisters</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfRegisters</i>)</h3>
<p>功能码 0x04, 读取从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfRegisters</i> 个输入寄存器，输入寄存器为只读.</p>
<!-- @@@readInputRegisters -->
<!-- $$$readWriteMultipleRegisters[overload1]$$$readWriteMultipleRegistersuint16_tuint16_tuint16_tstd::vector<uint16_t>&& -->
<h3 class="fn" translate="no" id="readWriteMultipleRegisters"><span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; Master::<span class="name">readWriteMultipleRegisters</span>(<span class="type">uint16_t</span> <i>readStartAddress</i>, <span class="type">uint16_t</span> <i>quantityToRead</i>, <span class="type">uint16_t</span> <i>writeStartAddress</i>, <span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; &amp;&amp;<i>writeData</i>)</h3>
<p>读写多个寄存器. 功能码 0x17. 读取开始地址 <i translate="no">readStartAddress</i>, 读取寄存器数量 <i translate="no">quantityToRead</i>, 写入寄存器开始地址 <i translate="no">writeStartAddress</i>, 写入数据 <i translate="no">writeData</i>.</p>
<!-- @@@readWriteMultipleRegisters -->
<!-- $$$readWriteMultipleRegisters$$$readWriteMultipleRegistersuint16_tuint16_tuint16_tconststd::vector<uint16_t>& -->
<h3 class="fn" translate="no" id="readWriteMultipleRegisters-1"><span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; Master::<span class="name">readWriteMultipleRegisters</span>(<span class="type">uint16_t</span> <i>readStartAddress</i>, <span class="type">uint16_t</span> <i>quantityToRead</i>, <span class="type">uint16_t</span> <i>writeStartAddress</i>, const <span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; &amp;<i>writeData</i>)</h3>
<p>This function overloads 重载函数..</p>
<p>功能码 0x17. 读取开始地址 <i translate="no">readStartAddress</i>, 读取寄存器数量 <i translate="no">quantityToRead</i>, 写入寄存器开始地址 <i translate="no">writeStartAddress</i>, 写入数据 <i translate="no">writeData</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#readWriteMultipleRegisters" translate="no">readWriteMultipleRegisters</a>.</p>
<!-- @@@readWriteMultipleRegisters -->
<!-- $$$reportServerID[overload1]$$$reportServerID -->
<h3 class="fn" translate="no" id="reportServerID"><span class="type">std::vector</span>&lt;<span class="type">uint8_t</span>&gt; Master::<span class="name">reportServerID</span>()</h3>
<p>报告从站ID. 功能码 0x11.</p>
<!-- @@@reportServerID -->
<!-- $$$requestReadFIFOQueue[overload1]$$$requestReadFIFOQueueuint16_t -->
<h3 class="fn" translate="no" id="requestReadFIFOQueue"><span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; Master::<span class="name">requestReadFIFOQueue</span>(<span class="type">uint16_t</span> <i>address</i>)</h3>
<p>读FIFO队列. 功能码 0x18. 从地址 <i translate="no">address</i> 开始读取.</p>
<!-- @@@requestReadFIFOQueue -->
<!-- $$$rtsDelay[overload1]$$$rtsDelay -->
<h3 class="fn" translate="no" id="rtsDelay">const <span class="type">std::chrono::milliseconds</span> &amp;Master::<span class="name">rtsDelay</span>() const</h3>
<p>返回RTS delay.</p>
<p><b>See also </b><a href="modbusover-master.html#setRTSDelay" translate="no">setRTSDelay</a>.</p>
<!-- @@@rtsDelay -->
<!-- $$$setAsciiLF[overload1]$$$setAsciiLFchar -->
<h3 class="fn" translate="no" id="setAsciiLF"><span class="type">void</span> Master::<span class="name">setAsciiLF</span>(<span class="type">char</span> <i>lf</i>)</h3>
<p>设置<a href="standard-h.html#ModbusProtocol-enum" translate="no">ModbusASCII</a>协议自定义LF <i translate="no">lf</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#asciiLF" translate="no">asciiLF</a>.</p>
<!-- @@@setAsciiLF -->
<!-- $$$setProtocolDebug[overload1]$$$setProtocolDebugstd::shared_ptr<ProtocolDebug> -->
<h3 class="fn" translate="no" id="setProtocolDebug"><span class="type">void</span> Master::<span class="name">setProtocolDebug</span>(<span class="type">std::shared_ptr</span>&lt;<span class="type"><a href="modbusover-protocoldebug.html" translate="no">ProtocolDebug</a></span>&gt; <i>debug</i>)</h3>
<p>设置底层协议调试接口 <i translate="no">debug</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#protocolDebug" translate="no">protocolDebug</a>.</p>
<!-- @@@setProtocolDebug -->
<!-- $$$setRTSDelay[overload1]$$$setRTSDelayconststd::chrono::milliseconds& -->
<h3 class="fn" translate="no" id="setRTSDelay"><span class="type">void</span> Master::<span class="name">setRTSDelay</span>(const <span class="type">std::chrono::milliseconds</span> &amp;<i>delay</i>)</h3>
<p>设置RTS <i translate="no">delay</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#rtsDelay" translate="no">rtsDelay</a>.</p>
<!-- @@@setRTSDelay -->
<!-- $$$setSlave[overload1]$$$setSlaveuint8_t -->
<h3 class="fn" translate="no" id="setSlave"><span class="type">void</span> Master::<span class="name">setSlave</span>(<span class="type">uint8_t</span> <i>slave</i>)</h3>
<p>设置从机编号 <i translate="no">slave</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#slave" translate="no">slave</a>.</p>
<!-- @@@setSlave -->
<!-- $$$setTimeout[overload1]$$$setTimeoutconststd::chrono::milliseconds& -->
<h3 class="fn" translate="no" id="setTimeout"><span class="type">void</span> Master::<span class="name">setTimeout</span>(const <span class="type">std::chrono::milliseconds</span> &amp;<i>timeout</i>)</h3>
<p>设置超时时间 <i translate="no">timeout</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#timeout" translate="no">timeout</a>.</p>
<!-- @@@setTimeout -->
<!-- $$$setUseBigendianCRC16[overload1]$$$setUseBigendianCRC16bool -->
<h3 class="fn" translate="no" id="setUseBigendianCRC16"><span class="type">void</span> Master::<span class="name">setUseBigendianCRC16</span>(<span class="type">bool</span> <i>on</i>)</h3>
<p>开启此选项 <i translate="no">on</i>, 将在<a href="standard-h.html#ModbusProtocol-enum" translate="no">ModbusRTU</a>中使用MSB在前，LSB在后的CRC16校验码，以应对某些非标准仪器.</p>
<div class="admonition note">
<p><b>Note: </b>在标准<a href="standard-h.html#ModbusProtocol-enum" translate="no">ModbusRTU</a>中，CRC16的校验码发送顺序是LSB在前，MSB在后.</p>
</div>
<p><b>See also </b><a href="modbusover-master.html#useBigendianCRC16" translate="no">useBigendianCRC16</a>.</p>
<!-- @@@setUseBigendianCRC16 -->
<!-- $$$slave[overload1]$$$slave -->
<h3 class="fn" translate="no" id="slave"><span class="type">uint8_t</span> Master::<span class="name">slave</span>() const</h3>
<p>返回从机编号.</p>
<p><b>See also </b><a href="modbusover-master.html#setSlave" translate="no">setSlave</a>.</p>
<!-- @@@slave -->
<!-- $$$timeout[overload1]$$$timeout -->
<h3 class="fn" translate="no" id="timeout">const <span class="type">std::chrono::milliseconds</span> &amp;Master::<span class="name">timeout</span>() const</h3>
<p>返回超时时间.</p>
<p><b>See also </b><a href="modbusover-master.html#setTimeout" translate="no">setTimeout</a>.</p>
<!-- @@@timeout -->
<!-- $$$useBigendianCRC16[overload1]$$$useBigendianCRC16 -->
<h3 class="fn" translate="no" id="useBigendianCRC16"><span class="type">bool</span> Master::<span class="name">useBigendianCRC16</span>() const</h3>
<p>返回在<a href="standard-h.html#ModbusProtocol-enum" translate="no">ModbusRTU</a>中是否使用MSB在前，LSB在后的CRC16校验码.</p>
<p><b>See also </b><a href="modbusover-master.html#setUseBigendianCRC16" translate="no">setUseBigendianCRC16</a>.</p>
<!-- @@@useBigendianCRC16 -->
<!-- $$$writeMultipleCoils[overload1]$$$writeMultipleCoilsuint16_tuint16_tstd::vector<uint8_t>&& -->
<h3 class="fn" translate="no" id="writeMultipleCoils"><span class="type">void</span> Master::<span class="name">writeMultipleCoils</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfCoils</i>, <span class="type">std::vector</span>&lt;<span class="type">uint8_t</span>&gt; &amp;&amp;<i>states</i>)</h3>
<p>功能码 0x0F, 写入从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfCoils</i> 线圈状态 <i translate="no">states</i>.</p>
<div class="admonition note">
<p><b>Note: </b>quantityOfCoils表示线圈数量，每个线圈为 1 bit, 所以 <i translate="no">states</i> 的字节数为 quantityOfCoils / 8 + ((quantityOfCoils % 8) ? 1 : 0).</p>
</div>
<p><b>See also </b><a href="modbusover-master.html#writeSingleCoil" translate="no">writeSingleCoil</a> and <a href="modbusover-master.html#readCoils" translate="no">readCoils</a>.</p>
<!-- @@@writeMultipleCoils -->
<!-- $$$writeMultipleCoils$$$writeMultipleCoilsuint16_tuint16_tconststd::vector<uint8_t>& -->
<h3 class="fn" translate="no" id="writeMultipleCoils-1"><span class="type">void</span> Master::<span class="name">writeMultipleCoils</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">uint16_t</span> <i>quantityOfCoils</i>, const <span class="type">std::vector</span>&lt;<span class="type">uint8_t</span>&gt; &amp;<i>states</i>)</h3>
<p>This function overloads 重载函数。.</p>
<p>功能码 0x0F, 写入从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">quantityOfCoils</i> 线圈状态 <i translate="no">states</i>.</p>
<div class="admonition note">
<p><b>Note: </b>quantityOfCoils表示线圈数量，每个线圈为 1 bit, 所以 <i translate="no">states</i> 的字节数为 quantityOfCoils / 8 + ((quantityOfCoils % 8) ? 1 : 0).</p>
</div>
<p><b>See also </b><a href="modbusover-master.html#writeMultipleCoils" translate="no">writeMultipleCoils</a>.</p>
<!-- @@@writeMultipleCoils -->
<!-- $$$writeMultipleRegisters[overload1]$$$writeMultipleRegistersuint16_tstd::vector<uint16_t>&& -->
<h3 class="fn" translate="no" id="writeMultipleRegisters"><span class="type">void</span> Master::<span class="name">writeMultipleRegisters</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, <span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; &amp;&amp;<i>values</i>)</h3>
<p>功能码 0x10, 写入从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">values</i> 个数的保持寄存器状态.</p>
<p><b>See also </b><a href="modbusover-master.html#writeSingleRegister" translate="no">writeSingleRegister</a> and <a href="modbusover-master.html#readHoldingRegisters" translate="no">readHoldingRegisters</a>.</p>
<!-- @@@writeMultipleRegisters -->
<!-- $$$writeMultipleRegisters$$$writeMultipleRegistersuint16_tconststd::vector<uint16_t>& -->
<h3 class="fn" translate="no" id="writeMultipleRegisters-1"><span class="type">void</span> Master::<span class="name">writeMultipleRegisters</span>(<span class="type">uint16_t</span> <i>startingAddress</i>, const <span class="type">std::vector</span>&lt;<span class="type">uint16_t</span>&gt; &amp;<i>values</i>)</h3>
<p>This function overloads 重载函数..</p>
<p>功能码 0x10, 写入从地址 <i translate="no">startingAddress</i> 开始的 <i translate="no">values</i> 个数的保持寄存器状态.</p>
<p><b>See also </b><a href="modbusover-master.html#writeMultipleRegisters" translate="no">writeMultipleRegisters</a>.</p>
<!-- @@@writeMultipleRegisters -->
<!-- $$$writeSingleCoil[overload1]$$$writeSingleCoiluint16_tbool -->
<h3 class="fn" translate="no" id="writeSingleCoil"><span class="type">void</span> Master::<span class="name">writeSingleCoil</span>(<span class="type">uint16_t</span> <i>address</i>, <span class="type">bool</span> <i>on</i>)</h3>
<p>功能码 0x05, 写位于地址 <i translate="no">address</i> 的单个线圈状态 <i translate="no">on</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#writeMultipleCoils" translate="no">writeMultipleCoils</a> and <a href="modbusover-master.html#readCoils" translate="no">readCoils</a>.</p>
<!-- @@@writeSingleCoil -->
<!-- $$$writeSingleRegister[overload1]$$$writeSingleRegisteruint16_tuint16_t -->
<h3 class="fn" translate="no" id="writeSingleRegister"><span class="type">void</span> Master::<span class="name">writeSingleRegister</span>(<span class="type">uint16_t</span> <i>address</i>, <span class="type">uint16_t</span> <i>value</i>)</h3>
<p>功能码 0x06, 写位于地址 <i translate="no">address</i> 的单个保持寄存器值 <i translate="no">value</i>.</p>
<p><b>See also </b><a href="modbusover-master.html#writeMultipleRegisters" translate="no">writeMultipleRegisters</a> and <a href="modbusover-master.html#readHoldingRegisters" translate="no">readHoldingRegisters</a>.</p>
<!-- @@@writeSingleRegister -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> ModbusOver
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/> </div>
</body>
</html>
